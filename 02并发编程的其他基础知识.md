# 第2章 并发编程的其他基础知识

##  并行与并发区别

并行指同一**时间段**多个任务同时都在进行，并且都没有执行结束，而并行是说在**单位时间**内多个任务在同时运行。

并发任务强调在一个时间段内同时进行，而一个时间段有多个单位i时间构成，所以说并发的多个任务在单位时间内不一定同时在执行。

一个CPU同时只能执行一个任务，所以单CPU时代多个任务都是并发执行的。

 >  注：在多线程时间中，线程的个数往往多于CPU个数，所以即使存在并行任务，一般还是称为多线程并发编程而非多线程并行编程。

## Java中的线程安全问题

示例：计数器问题

|       | t1                          | t2                          | t3                    | t4         |
| ----- | --------------------------- | --------------------------- | --------------------- | ---------- |
| 线程A | 从主内存读取count值到本线程 | 递增本地线程count的值       | 写回主内存            |            |
| 线程B |                             | 从主内存读取count值到本线程 | 递增本地线程count的值 | 写回主内存 |

假设count初始值为0，线程A在t1和t2时间读取了主内存中的count并在本地将其递增为1，t2时线程B从主内存中读取了count的值0并于t3时将其递增为1，t3时线程A将count的新值1更新到主内存，t4时线程B进行了同样的操作，最终主内存中count的值为2而非我们想要的3。

## Java中共享变量的内存可见性问题

![](/images/02.png)


如图是一个双核CPU模型，每个和都有自己的一级缓存，有些架构里还有一个所有CPU共享的二级缓存。

现假设线程A和线程B同时处理一个共享变量，由于Cache的存在，将会出现**内存不可见**问题，原因如下：

- 线程A先获取共享变量X的值（假设X=0），由于L1和L2缓存中都没有X的值，线程A会直接从主存中去取X的值并将其缓存到L1和L2中。然后A将X的值递增为1，将其写入缓存L1和L2，并刷新到主存。
- 线程B也要获取X的值，由于Core2中1级缓存没有X的值，B会从L2缓存取到X的值1。然后B修改X为2，将其更新至L1、L2和主存。
- 线程A又需要获取X的值，发现L1中已经有了，但此时A获得的X=1，与主存中X=2不同了！

## synchronized关键字

synchronized关键字是一种原子性内置锁，线程进入synchronized代码块前会自动获取监视器锁，这时其他线程再访问该同步代码块是会被阻塞挂起。

前面的共享变量内存可见性问题主要是线程的工作内存导致的，而synchronized可以解决此问题。


